{
  "name": "DRCT Search Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "drct/search",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "b8c0c7e8-8f3a-4e5a-9e1a-1e8f9c7a3e1a",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "drct-search"
    },
    {
      "parameters": {
        "jsCode": "// Transform Aviaframe format to DRCT API format\nconst body = $input.item.json.body;\n\nif (!body) {\n  throw new Error('Request body is required');\n}\n\n// Validate required fields\nif (!body.origin || !body.destination || !body.depart_date) {\n  throw new Error('origin, destination, and depart_date are required');\n}\n\n// Ensure date format is YYYY-MM-DD\nfunction formatDate(dateStr) {\n  if (!dateStr) return null;\n  // If already in YYYY-MM-DD format, return as is\n  if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n    return dateStr;\n  }\n  // Try to parse and format\n  const date = new Date(dateStr);\n  if (isNaN(date.getTime())) {\n    throw new Error(`Invalid date format: ${dateStr}`);\n  }\n  return date.toISOString().split('T')[0];\n}\n\n// Build flights array\nconst flights = [];\n\n// Outbound flight\nflights.push({\n  departure_airport_code: body.origin.toUpperCase(),\n  arrival_airport_code: body.destination.toUpperCase(),\n  departure_date: formatDate(body.depart_date)\n});\n\n// Return flight (if provided)\nif (body.return_date) {\n  flights.push({\n    departure_airport_code: body.destination.toUpperCase(),\n    arrival_airport_code: body.origin.toUpperCase(),\n    departure_date: formatDate(body.return_date)\n  });\n}\n\n// Build passengers array\nconst passengers = [];\n\n// Add adults (default to 1 if not provided)\nconst adults = body.adults || 1;\nfor (let i = 0; i < adults; i++) {\n  passengers.push({ type: \"ADT\" });\n}\n\n// Add children\nconst children = body.children || 0;\nfor (let i = 0; i < children; i++) {\n  passengers.push({ type: \"CHD\" });\n}\n\n// Add infants\nconst infants = body.infants || 0;\nfor (let i = 0; i < infants; i++) {\n  passengers.push({ type: \"INF\" });\n}\n\n// Build DRCT request\nconst drctRequest = {\n  flights: flights,\n  passengers: passengers\n};\n\n// Add filters if cabin_class is provided\nif (body.cabin_class) {\n  drctRequest.filters = {\n    cabin_class: body.cabin_class.toLowerCase()\n  };\n}\n\nconsole.log('[Transform] Converted to DRCT format:', JSON.stringify(drctRequest, null, 2));\n\nreturn drctRequest;"
      },
      "id": "a0b1c2d3-4e5f-6a7b-8c9d-0e1f2a3b4c5d",
      "name": "Transform to DRCT Format",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://sandbox-api.drct.aero/offers_search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "DRCT-Version",
              "value": "2021-06-01"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json",
              "neverError": true
            }
          },
          "timeout": 30000
        }
      },
      "id": "a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "name": "DRCT Search API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [690, 300]
    },
    {
      "parameters": {
        "jsCode": "// Transform DRCT API response to Aviaframe format\nlet data = $input.item.json;\n\n// DRCT returns array with single object [{...}]\nif (Array.isArray(data) && data.length > 0) {\n  data = data[0];\n}\n\nconsole.log('[Transform] Data keys:', Object.keys(data));\n\nconst offers = data.offers || [];\nconst segments = data.segments || [];\nconst fares = data.fares || [];\nconst flights = data.flights || [];\n\nconsole.log(`[Transform] Found ${offers.length} offers, ${segments.length} segments, ${fares.length} fares, ${flights.length} flights`);\n\n// Create lookup maps\nconst segmentMap = {};\nsegments.forEach(seg => {\n  if (seg && seg.id) {\n    segmentMap[seg.id] = seg;\n  }\n});\n\nconst fareMap = {};\nfares.forEach(fare => {\n  if (fare && fare.id) {\n    fareMap[fare.id] = fare;\n  }\n});\n\nconsole.log(`[Transform] Maps created - segments: ${Object.keys(segmentMap).length}, fares: ${Object.keys(fareMap).length}`);\n\n// Transform offers\nconst transformedOffers = offers.map((offer, index) => {\n  console.log(`[Transform] Processing offer ${index}:`, offer.id);\n  \n  // Get first fare from offer.fares array\n  const offerFare = offer.fares && offer.fares[0];\n  if (!offerFare) {\n    console.log(`[Transform] No fares in offer ${offer.id}`);\n  }\n  \n  const fareId = offerFare?.id;\n  const fare = fareId ? fareMap[fareId] : null;\n  \n  // Get segment IDs from fare.segments\n  const segmentIds = offerFare?.segments || [];\n  console.log(`[Transform] Offer ${offer.id} has ${segmentIds.length} segment IDs:`, segmentIds);\n  \n  // Look up actual segment objects\n  const flightSegments = segmentIds\n    .map(id => segmentMap[id])\n    .filter(seg => seg != null);\n  \n  console.log(`[Transform] Found ${flightSegments.length} segments for offer ${offer.id}`);\n  \n  // Get first and last segment\n  const firstSegment = flightSegments[0] || {};\n  const lastSegment = flightSegments[flightSegments.length - 1] || {};\n  \n  // Extract data (nested objects!)\n  const airlineCode = firstSegment.carrier?.airline_code || 'N/A';\n  const airlineName = firstSegment.carrier?.airline_name || airlineCode;\n  \n  return {\n    offer_id: offer.id || `offer-${index}`,\n    origin: firstSegment.departure_airport?.code || 'N/A',\n    destination: lastSegment.arrival_airport?.code || 'N/A',\n    departure_time: firstSegment.departure_date && firstSegment.departure_time \n      ? `${firstSegment.departure_date} ${firstSegment.departure_time}` \n      : 'N/A',\n    arrival_time: lastSegment.arrival_date && lastSegment.arrival_time\n      ? `${lastSegment.arrival_date} ${lastSegment.arrival_time}`\n      : 'N/A',\n    airline_code: airlineCode,\n    airline_name: airlineName,\n    flight_number: firstSegment.flight_number || 'N/A',\n    price: {\n      total: offer.price?.amount || 0,\n      currency: offer.price?.currency || 'USD',\n      base: offer.price_details?.[0]?.price?.fare?.amount || 0,\n      taxes: offer.price_details?.[0]?.price?.taxes?.amount || 0\n    },\n    duration: firstSegment.duration || 0,\n    stops: Math.max(0, flightSegments.length - 1),\n    cabin_class: fare?.cabin_class || 'Economy',\n    baggage: fare?.baggage?.[0] || {},\n    segments: flightSegments.map(seg => ({\n      origin: seg.departure_airport?.code,\n      destination: seg.arrival_airport?.code,\n      departure: `${seg.departure_date} ${seg.departure_time}`,\n      arrival: `${seg.arrival_date} ${seg.arrival_time}`,\n      carrier: seg.carrier?.airline_code,\n      flight_number: seg.flight_number,\n      aircraft: seg.aircraft,\n      duration: seg.duration\n    }))\n  };\n});\n\nconsole.log(`[Transform] Created ${transformedOffers.length} offers`);\nif (transformedOffers.length > 0) {\n  console.log('[Transform] Sample offer:', JSON.stringify(transformedOffers[0], null, 2));\n}\n\nreturn {\n  search_id: data.id || 'unknown',\n  offers: transformedOffers\n};"
      },
      "id": "c5d6e7f8-9a0b-1c2d-3e4f-5a6b7c8d9e0f",
      "name": "Transform Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [910, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "responseCode": 200
        }
      },
      "id": "d7e8f9a0-1b2c-3d4e-5f6a-7b8c9d0e1f2a",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1130, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  error: {\n    code: 'DRCT_API_ERROR',\n    message: 'Failed to fetch search results from DRCT API',\n    details: $json.error || $json.message || 'Unknown error'\n  }\n}) }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "f9a0b1c2-3d4e-5f6a-7b8c-9d0e1f2a3b4c",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [690, 480]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Transform to DRCT Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform to DRCT Format": {
      "main": [
        [
          {
            "node": "DRCT Search API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DRCT Search API": {
      "main": [
        [
          {
            "node": "Transform Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2026-01-27T00:00:00.000Z",
      "updatedAt": "2026-01-27T00:00:00.000Z",
      "id": "1",
      "name": "DRCT"
    },
    {
      "createdAt": "2026-01-27T00:00:00.000Z",
      "updatedAt": "2026-01-27T00:00:00.000Z",
      "id": "2",
      "name": "Search"
    }
  ],
  "meta": {
    "instanceId": "local"
  },
  "pinData": {},
  "versionId": "2",
  "triggerCount": 0,
  "active": false
}
