# DRCT Integration Notes

Version: 1.1  
Date: 2026-01-26  
Author: Engineering / Integrations

Overview
--------
This document summarizes the integration rules, constraints and operational guidance for Aviaframe's adapter to the DRCT supplier API. It is written for engineers implementing or operating the DRCT adapter, SREs responding to provider issues, and product/partner teams that must understand provider constraints. The DRCT API is a critical external dependency — Aviaframe must wrap it conservatively to protect tenants, preserve availability, and prevent credential or PII leaks.

Key principles
- All DRCT interactions occur server-side in Aviaframe's DRCT adapter. DRCT bearer tokens and secrets are never exposed to the widget or client-side code.
- Tenant isolation is enforced in the adapter — every DRCT call is tagged and logged with tenant context but credentials remain backend-only.
- Respect DRCT rate limits and contractual rules. Use queuing, coalescing and caching where allowed.
- Persist idempotency records for operations that cause provider side-effects (order create, issue).
- Sanitize and mask all PII before persisting or emitting any logs.

1. Environments
----------------
- Sandbox environment
  - Use DRCT sandbox endpoints for development, QA and CI integration tests.
  - Sandbox credentials are separate from production and must be stored in secrets manager.
  - Integration tests should be run regularly against sandbox to validate workflows and to capture contract/regression changes.

- Production environment
  - Production DRCT endpoints and production credentials must be stored in the secrets manager and accessed only by backend services running in production.
  - Credentials for sandbox and production are logically and physically separated. Never use production tokens in sandbox or commit them to repositories.

Operational note:
- Use environment-specific configuration to switch endpoints and credentials.
- Maintain separate monitoring/alerting thresholds for sandbox vs production usage.

2. Required headers & request tracing
-------------------------------------
Every outbound DRCT request from Aviaframe MUST include:

- Authorization: Bearer <DRCT_TOKEN>
  - Token retrieved from secrets manager; do not hardcode.
- Content-Type: application/json
- Accept: application/json
- x-correlation-id: <uuid>
  - Generated by Aviaframe per incoming client request (propagate if client provided one). Persist correlation id in DRCTRequestLog for tracing.
- x-avf-tenant-id: <tenant_id> (meta header)
  - Optional: include tenant_id as a non-sensitive metadata header if DRCT supports vendor metadata; otherwise keep tenant_id internal only.
- Idempotency-Key: <uuid>
  - Required for order_create and issue calls (see Idempotency rules).

Notes:
- Never include or forward Aviaframe internal secrets or tenant API keys to DRCT.
- If DRCT returns a Retry-After header, use its value to schedule retries or backoff.

3. Rate limits
---------------
DRCT enforces per-account and per-endpoint rate limits. The adapter must protect DRCT accounts from overuse.

Hard rule (example):
- offers_search = 1 request/second (1 rps)
  - This is a strict limit and is used as the baseline in this document. Confirm the exact contractual limits with DRCT for your account.

Adapter responsibilities:
- Enforce per-tenant and global rate limits:
  - Per-tenant token-bucket based on tenant's subscription plan.
  - Global (provider) token-bucket that aggregates all tenants that share a DRCT account so total outbound RPS never exceeds provider contract.
- Request coalescing:
  - If multiple identical search requests (same key: origin, destination, dates, pax, cabin, currency) arrive within a short window (e.g., 300–500 ms), coalesce them into a single DRCT offers_search call and fan-out the response to all requesters, subject to caching rules.
- Caching:
  - Cache offers where allowed by DRCT and only for the TTL indicated by DRCT or a safe default (e.g., no longer than offer valid_until). Use cache keys that include tenant_id and search criteria.
  - Respect fare validity windows — do not serve stale offers beyond valid_until.
- Queueing and smoothing:
  - When the global bucket is exhausted, queue requests and schedule them according to Retry-After or backoff policy rather than failing immediately (for non-interactive callers). For interactive requests (widget/portal), prefer returning 429 with Retry-After so clients can surface a retry UI.
- Circuit breaker:
  - If DRCT returns sustained 5xx/429 errors, engage circuit-breaker to protect platform and alert SREs.

4. Idempotency rules
--------------------
Idempotency is mandatory for operations that create persistent external state in DRCT.

Required behavior:
- Operations requiring idempotency:
  - Order creation (order_create)
  - Ticket issuing (issue)
  - Any adapter method that maps to non-idempotent DRCT calls

- Client contract:
  - Aviaframe API requires clients include an Idempotency-Key header (UUID) for POST /public/orders and POST /public/orders/{id}/issue. The backend adapter must use the same idempotency key when calling DRCT if DRCT supports provider-side idempotency headers; otherwise the adapter must persist the mapping and enforce idempotency server-side.

- Server-side enforcement:
  - Persist IdempotencyRecord keyed by (tenant_id, operation_type, idempotency_key).
  - On first request:
    - Create IdempotencyRecord with status=IN_PROGRESS inside a transaction and then perform DRCT call.
  - On subsequent requests with same key:
    - If the original completed successfully, return the stored result.
    - If original is IN_PROGRESS, wait/signal or return 202/409 per policy to client.
    - If payload differs from the original, return 409 Conflict.
  - TTL:
    - Keep idempotency records for a configurable TTL (recommended default: 7 days) to guard against duplicate retries.

- Partial success & reconciliation:
  - If DRCT reports success but Aviaframe didn't persist result (e.g., network timeout), reconciliation process must query DRCT using any available identifiers and reconcile OrderRecord to avoid duplicate bookings.

5. Offer TTL and pricing rules
-------------------------------
- Offer validity
  - DRCT returns offers with a validity window (valid_until) or an expiry duration. Aviaframe MUST surface valid_until to clients and enforce it:
    - Do not allow order_create for an offer after valid_until.
    - On expiry, return AVF_404_OFFER_NOT_FOUND or AVF_409_PRICE_CHANGED with guidance to re-search.
- Repricing
  - Clients should call PATCH /public/offers/{offerId}/price to confirm final price before order creation.
  - If price or fare rules changed between search and price confirmation:
    - Return 409 Conflict with details (new_price provided if available) and instruct the client to reprice or re-search.
- Markups and fees
  - Aviaframe applies tenant-configured markups/fees after DRCT pricing returns final numbers. The breakdown must include:
    - base, taxes, provider_fees, aviaframe_markup, tenant_markup (if separate), total.
  - Markups are applied server-side only and recorded in OrderRecord for auditability.
- Cache semantics
  - Only cache offers if DRCT contract allows it. Cache duration must be shorter than or equal to the provider-specified validity.
  - Use tenant-scoped cache and include currency and locale in cache key.

6. Booking & issuing constraints
--------------------------------
- Pre-conditions
  - Offer must be valid and priced prior to order_create where DRCT requires it.
  - Passenger details must be complete and validated (name formats, document expiry, required fields) before creating orders.
  - For issuing, payment must be confirmed externally (MVP) or internally (v2) depending on tenant configuration.

- Booking flow
  - POST /public/orders:
    - Validate payload and passenger documents.
    - Persist OrderRecord with status=PENDING before calling DRCT order_create to enable reconciliation and idempotency.
    - On DRCT success: persist drct_order_id and set status to BOOKED (or as per DRCT semantics).
    - On partial/uncertain response: set status to PENDING_RECONCILE, schedule reconciliation job, notify ops if necessary.

- Issuing flow
  - POST /public/orders/{orderId}/issue:
    - Verify OrderRecord is in correct state and payment proof provided.
    - Use Idempotency-Key to protect reuse.
    - On success: persist ticket numbers, set status=ISSUED and record issue-related DRCTRequestLog.
    - On failure: apply retry/backoff rules; if unrecoverable, set status to FAILED and surface clear error.

- Cancellation & refunds
  - Cancellation depends on fare rules returned by DRCT. Adapter must:
    - Check fare_rules and DRCT cancel policies before attempting cancellation.
    - Call provider cancel endpoints and persist the result (partial/full).
    - Record refund_reference if provided; refunds are handled outside Aviaframe MVP (agency or PSP), but refund metadata is recorded for reconciliation.
  - For partial cancellations (per passenger/segment), update OrderRecord appropriately and record granular DRCTRequestLog entries.

- Retry & backoff policies for booking/issuing
  - On 429:
    - If DRCT returns Retry-After, honor it.
    - Otherwise use exponential backoff with jitter (1s, 2s, 4s), max 3 retries.
  - On 5xx:
    - Retry up to 3 times with exponential backoff and jitter.
  - On client/400 errors:
    - Treat as permanent errors; do not retry automatically.
  - All retries must preserve idempotency guarantees.

7. How Aviaframe wraps DRCT safely for agencies
-----------------------------------------------
Aviaframe provides a protective, tenant-scoped abstraction over DRCT that delivers business, security, and operational value to agencies:

- Backend-only credentials
  - DRCT tokens live only in a secrets manager and are used only by the backend DRCT adapter. The widget and portal clients never receive provider tokens.

- Tenant scoping & RBAC
  - The adapter enforces tenant isolation at every call. Tenant context is resolved from the authenticated client token or API key — clients cannot impersonate other tenants.

- Rate-limit protection & aggregation
  - Aviaframe shields agencies from DRCT rate limits by queuing, coalescing identical searches and applying plan-based smoothing so one tenant does not exhaust shared provider capacity.

- Idempotency and reconciliation
  - Aviaframe enforces idempotency for order creation and issuing and provides reconciliation logic for partial or uncertain provider responses, reducing booking duplication risk for agencies.

- PII handling & masking
  - Passenger PII is encrypted at rest, masked in logs, and only decrypted in-memory when strictly required. Aviaframe minimizes what is persisted and provides tenant-scoped export / deletion capabilities.

- Normalized API & billing
  - The Aviaframe API returns normalized offers and a consistent pricing breakdown. Aviaframe also meters usage (searches, bookings) for billing and quota enforcement, while logging provider interactions for traceability.

- Auditability & observability
  - All DRCT interactions are recorded in DRCTRequestLog (sanitized) and order lifecycle changes are recorded in AuditLog. Correlation IDs propagate through the flow to make debugging and reconciliation practical.

- Error translation & UX-safe responses
  - The adapter maps provider errors to stable Aviaframe error codes and human-friendly messages so agencies can surface sensible UI guidance (e.g., “Fare expired — please re-search”, “Rate limit reached — try again in Xs”).

Operational recommendations
---------------------------
- Maintain and test the reconciliation worker with sandbox DRCT scenarios that simulate timeouts and partial success cases.
- Keep detailed runbooks for DRCT credential rotation, 401 spikes, and rate-limit saturation events.
- Regularly verify that caching/coalescing logic does not serve stale or invalid offers beyond provider-specified validity periods.
- Monitor DRCT 401/429/5xx counts and alert early.

References
----------
- docs/03_SRS.md — Error handling, retry rules and idempotency patterns.
- docs/06_API_SPEC.md — Aviaframe public API that consumes the DRCT adapter.
- docs/08_SECURITY.md — Secrets, PII and token handling policies.

If you need a concrete adapter code sketch, test harnesses for sandbox, or reconciliation job templates, request a follow-up and we will produce implementation-ready examples.